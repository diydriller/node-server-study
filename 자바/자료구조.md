## 1. HashMap
* Map 인터페이스의 구현체로 key와 value의 쌍으로 데이터를 저장하는 자료구조이다.
* key로 객체를 넣을때 객체의 hashcode 메서드를 사용한다. equals 메서드를 재정의할때
hashcode 메서드도 재정의해줌으로써 equals 메서드가 같다고 하면 hashcode 메서드도 같도록
해줘야한다.
* 자료의 저장순서를 유지하지않는다. 저장순서를 유지하기위해서는 HashMap을 상속받는 LinkedHashMap을
사용해야한다.
* ### 시간복잡도
* 원소 삽입시 key에 해당하는 객체의 hashcode 메서드를 사용해서 배열에 LinkedList 형태로 삽입한다.
해시충돌이 일어날 경우 LikedList의 마지막에 삽입한다. LinkedList의 크기가 일정크기 이상으로
커지면 Tree형태로 바꾼다. 
* 충돌이 일어나지 않는다면 삽입 , 삭제 , 조회 시간복잡도는 O(1)이다.
* ### 충돌
* Open Addressing은 충돌발생시 다른 버킷에 자료를 저장하는 방법이다.
* Separate Chaining은 충돌발생시 해당 버킷을 링크드리스트나 트리(레드블랙트리)로 만드는 방법으로
Separate Chaining을 채택해서 사용하고 있다.
* ### 동기화
* HashMap은 thread safe하지 않다. 
* Hashtable은 synchronized를 사용해서 동기화를 한다. lock을 걸어서 다른 스레드가 
임계영역에 접근하는 것을 막는다. 
* ConcurrentHashMap은 lock없이 CAS(Compare And Swap)알고리즘을 사용해서 동기화를 한다.
스레드의 값과 메모리의 값을 비교해서 같을 경우에만 업데이트하고 다르면 재시도를 한다.

## 2. TreeMap
* Map 인터페이스의 구현체로 key와 value의 쌍으로 데이터를 저장하는 자료구조이다.
* key의 Comparator를 기준으로 key를 정렬하여 이분탐색트리의 일종인 레드블랙트리로 저장한다.
* ### 시간복잡도
* 레드블랙트리의 높이만큼 탐색을 하기때문에 삽입 , 삭제 , 조회 시간복잡도는 O(log n)이다.

## 3. ArrayList
* List 인터페이스의 구현체로 데이터를 순서대로 저장하는 자료구조로 크기를 조절할 수 있다. 
* 내부적으로 배열을 사용한다.
* ### 시간복잡도
* 원소를 마지막에 삽입시 공간이 꽉 차면 기존 배열의 크기의 50%를 더해서 새로운 크기의 배열을 
만들고 기존배열을 복사한다. 공간이 꽉 차게 되면 시간복잡도는 O(n)이 걸리고 그렇지 않다면 O(1)이 걸린다. 
* 마지막이 아닌 원소 삭제시 다음 원소를 앞 원소에 덮어쓰고 마지막원소를 null처리를 해서 gc가
메모리를 수거하도록 한다. 시간복잡도는 O(n)이 걸린다. 
* 조회시 인덱스를 사용하기때문에 시간복잡도는 O(1)이 걸린다.

## 4. LinkedList
* List 인터페이스의 구현체로 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어있는 자료구조이다.
* ### 시간복잡도
* 원소를 마지막이나 처음에 삽입하거나 삭제할때 시간복잡도는 O(1)이 걸린다. 원소를 중간에 삽입하거나
삭제할때는 인덱스만큼 탐색이 필요하므로 O(n)이 걸린다. 

## 5. String
* 문자열을 저장하는 자료구조이다.
* 내부적으로 배열을 사용한다.
* ### 메모리
* heap의 string constant pool이라는 곳에 메모리를 할당받고 같은 문자열이면 
같은 주소를 참조한다. 



